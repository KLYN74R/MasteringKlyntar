---
cover: ../../.gitbook/assets/43310060263553.5a4f4c443dce3.gif
coverY: -104.62074978204011
---

# ðŸ•µ VRF

### <mark style="color:red;">Briefly</mark>

A verifiable random function (VRF) is a cryptographic primitive that uses a pair of keys and, based on some input data, can generate pseudo-random values â€‹â€‹while also creating a proof that it was calculated correctly.

This "testable randomness" can be extremely important for special use cases within services or workflows.

Only the owner of the private key can calculate the hash and proof, but anyone with the public key can verify the hash is correct and the proof is valid.

Some code

You can see a small example right in the kernel repository. And although VRF is not yet included in our developments, it is nevertheless available for use and application in your developments.

You can see this example here

{% embed url="https://github.com/KLYN74R/KlyntarCore/blob/main/KLY_Utils/zkp/vrf.js" %}

Let's clarify it with code example

```javascript
import { Evaluate, ProofHoHash } from '@idena/vrf-js'


import('module').then(
                
    mod => mod.createRequire(import.meta.url)

).then(require=>{

    //ECDSA keypair
    let {Wallet} = require('../signatures/ringsig/lrs-ecdsa/export.js')

    const w = Wallet.createRandom()
       
    // let PUB=new Uint8Array(Buffer.from(w.signingKey.publicKey.slice(2),'hex'))
    // let PRV=new Uint8Array(Buffer.from(w.privateKey.slice(2),'hex'))

    let PUB=[
        4, 122,  92, 149, 185, 212,  27,  32, 237,   9,  17,
      229,  95, 254, 167,  98,  39, 136, 244, 252,  50, 132,
       64, 228, 115,  67,   0, 254, 222,  45,  93,  13, 233,
       92,  96, 204,  86, 140, 161,  44,  88, 175, 154, 101,
      228, 220,  16, 145,  21,  41, 164,  39, 234,   8, 213,
      132, 131, 228,  19,  94,  72,  78,  56,  57, 102
    ]
    let PRV = [
      221, 183, 155, 169,  12,  42, 157, 125,
       84, 174, 228,  11,  75, 134, 107,  43,
      106,  54, 210,   5, 223,  70, 215, 124,
       29, 210,  64, 253, 142, 170, 233,  16
    ]
  
    console.log('PUB ',PUB)
    console.log('PRV ',PRV)

    

    // evaluate VRF proof from private key

    const data = [1, 2, 3, 4, 5] // data
    const [hash, proof] = Evaluate(PRV,data)

    console.log('Hash is ',hash)
    console.log('Proof is ',proof)

    // check VRF proof with public key
    // throws exception if proof is invalid
    const hashCheck = ProofHoHash(PUB, data, proof)


    console.log(hashCheck)

})
```

Let's see what's going on here

<mark style="color:yellow;">**Initially you generate a key pair**</mark>

VRF can be built on any curves, but it uses secp256k1 curve and ECDSA to generate key pairs. In general, we took the same keys that we use to generate key pairs for ring signatures (that is, there will again be ETH compatibility).

![Keys in bytes format](<../../.gitbook/assets/image (11) (1).png>)

<mark style="color:yellow;">**Step 2 - Computation**</mark>

Next comes the hash calculation and proof. Here the data is represented as bytes. The hash becomes public and is used as the very "random value", and the proof - as proof of the reliability of the calculation.

![](<../../.gitbook/assets/image (27) (1).png>)

<mark style="color:yellow;">**Step 3 - Verification**</mark>

Anyone with the public key, the original input, and the proof can verify the validity of the computation by taking the hash and comparing it to the original.

![](<../../.gitbook/assets/image (24) (1).png>)

### <mark style="color:red;">So what's the catch here?</mark>

For those who have not yet understood, the point here is that even the owner of the private key cannot specifically choose the right hash value. No one can manipulate or deliberately select a random value. It is also of interest that before the publication of the hash and proof, no one can guess this random value that was generated by some address.

### <mark style="color:red;">Usecase</mark>

Let's imagine that a group of people (2 people) are playing a game in which everyone receives the input string <mark style="color:purple;">**THIS IS A GAME**</mark> and generates 32 byte hashes using VRF. This continues 3 times and each time the input will be the hash obtained in the previous step. After that, they sum up the hash values. Whoever has the most amount wins. Each of them has a pair of keys and each knows the public key of the other. You can visualize it like this

![](<../../.gitbook/assets/image (12) (1).png>)

At the same time, both Alice and Bob will be sure of the impossibility of obtaining other data and the fairness of this game.

### <mark style="color:red;">Where can it be useful and where is it applied?</mark>

Here we explained the VRF mechanism in a simplified way, but Algorand consensus works in a similar way.

{% embed url="https://medium.com/algorand/algorand-releases-first-open-source-code-of-verifiable-random-function-93c2960abd61" %}

We assume the use of VRF in smart contracts and services on KLYNTAR

### <mark style="color:red;">Links</mark>

{% embed url="https://blog.chain.link/verifiable-random-function-vrf/" %}

{% embed url="https://medium.com/asecuritysite-when-bob-met-alice/verifiable-random-functions-4563d6eb17ab" %}

{% embed url="https://medium.com/algorand/algorand-releases-first-open-source-code-of-verifiable-random-function-93c2960abd61" %}
